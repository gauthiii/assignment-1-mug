# This is the main configuration file for the application.
# https://www.playframework.com/documentation/latest/ConfigFile
include "akka"
play.http.secret.key=this-is-a-very-long-key-12764978qteriugwfiabcou



# Point JPA at our database configuration
jpa.default=defaultPersistenceUnit

play
{
akka.stream.materializer.max-input-buffer-size = 128
akka.http.server.idle-timeout = infinite
akka.http.client.idle-timeout  = infinite
}

# Number of database connections
# See https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing
fixedConnectionPool = 9

db.default {
  driver = org.h2.Driver
  url = "jdbc:h2:mem:play"

  # Provided for JPA access
  jndiName=DefaultDS

  # Set Hikari to fixed size
  hikaricp.minimumIdle = ${fixedConnectionPool}
  hikaricp.maximumPoolSize = ${fixedConnectionPool}
}


play.filters
{
	enabled += play.filters.hosts.AllowedHostsFilter
	enabled += play.filters.cors.CORSFilter	
		
	# Allowed hosts filter configuration
	hosts 
	{
		# Allow requests to localhost on ports 9000 (dev) and 19001 (default test) ports
		allowed = ["localhost:9000", "localhost:19001", "snakegame.com:9000" ,"10.151.71.215:9000"]
	}
	
	 # CSRF config
  csrf {

    # Token configuration
    token {
      # The token name
      name = "csrfToken"

      # Whether tokens should be signed or not
      sign = true
    }

    # Cookie configuration
    cookie {
      # If non null, the CSRF token will be placed in a cookie with this name
      name = null

      # Whether the cookie should be set to secure
      secure = ${play.http.session.secure}

      # Whether the cookie should have the HTTP only flag set
      httpOnly = false

      # The value of the SameSite attribute of the cookie. Set to null for no SameSite attribute.
      # Possible values are "lax" and "strict". If misconfigured it's set to null.
      sameSite = ${play.http.session.sameSite}
    }

    # How much of the body should be buffered when looking for the token in the request body
    body.bufferSize = ${play.http.parser.maxMemoryBuffer}

    # Bypass the CSRF check if this origin is trusted by the CORS filter
    bypassCorsTrustedOrigins = true

    # Header configuration
    header {

      # The name of the header to accept CSRF tokens from.
      name = "Csrf-Token"


      # Defines headers that must be present to perform the CSRF check. If any of these headers are present, the CSRF
      # check will be performed.
      #
      # By default, we only perform the CSRF check if there are Cookies or an Authorization header.
      # Generally, CSRF attacks use a user's browser to execute requests on the client's behalf. If the user does not
      # have an active session, there is no danger of this happening.
      #
      # Setting this to null or an empty object will protect all requests.
      protectHeaders {
        Cookie = "*"
        Authorization = "*"
      }

      # Defines headers that can be used to bypass the CSRF check if any are present. A value of "*" simply
      # checks for the presence of the header. A string value checks for a match on that string.
      bypassHeaders {}
    }

    # Method lists
    method {
      # If non empty, then requests will be checked if the method is not in this list.
      whiteList = ["GET", "POST", "HEAD", "OPTIONS"]

      # The black list is only used if the white list is empty.
      # Only check methods in this list.
      blackList = []
    }

    # Content type lists
    # If both white lists and black lists are empty, then all content types are checked.
    contentType {
      # If non empty, then requests will be checked if the content type is not in this list.
      whiteList = ["application/json"]

      # The black list is only used if the white list is empty.
      # Only check content types in this list.
      blackList = []
    }

    routeModifiers {
      # If non empty, then requests will be checked if the route does not have this modifier. This is how we enable the
      # nocsrf modifier, but you may choose to use a different modifier (such as "api") if you plan to check the
      # modifier in your code for other purposes.
      whiteList = ["nocsrf"]

      # If non empty, then requests will be checked if the route contains this modifier
      # The black list is used only if the white list is empty
      blackList = []
    }

    # The error handler.
    # Used by Play's built in DI support to locate and bind a request handler.  Must be one of the following:
    # - A FQCN that implements play.filters.csrf.CSRF.ErrorHandler (Scala).
    # - A FQCN that implements play.filters.csrf.CSRFErrorHandler (Java).
    # - provided, indicates that the application has bound an instance of play.filters.csrf.CSRF.ErrorHandler through some
    #   other mechanism.
    # If null, will attempt to load a class called CSRFErrorHandler in the root package, otherwise if that's
    # not found, will default to play.filters.csrf.CSRF.CSRFHttpErrorHandler, which delegates to the configured
    # HttpRequestHandler.
    errorHandler = null
  }
      
	# CORS filter configuration
	  cors 
	  {

		# The path prefixes to filter.
		pathPrefixes = ["/"]

		# The allowed origins. If null, all origins are allowed.
		allowedOrigins = ["http://localhost:9000", "localhost:19001", "http://snakegame.com:9000/setRunState" ,"10.151.71.215:9000"]
		#allowedOrigins = null
		
		# The allowed HTTP methods. If null, all methods are allowed
		allowedHttpMethods = ["GET", "POST", "HEAD", "OPTIONS"]

		# The allowed HTTP headers. If null, all headers are allowed.
		allowedHttpHeaders = null

		# The exposed headers
		exposedHeaders = []

		# Whether to support credentials
		supportsCredentials = true

		# The maximum amount of time the CORS meta data should be cached by the client
		preflightMaxAge = 1 hour

		# Whether to serve forbidden origins as non-CORS requests
		serveForbiddenOrigins = true
	  }
	  
	  # Method lists
    method {
      # If non empty, then requests will be checked if the method is not in this list.
      whiteList = ["GET", "POST", "HEAD", "OPTIONS"]

      # The black list is only used if the white list is empty.
      # Only check methods in this list.
      blackList = []
    }
	
	# Content type lists
    # If both white lists and black lists are empty, then all content types are checked.
    contentType {
      # If non empty, then requests will be checked if the content type is not in this list.
      whiteList = ["application/json"]

      # The black list is only used if the white list is empty.
      # Only check content types in this list.
      blackList = []
    }

	
  }
    
  
# disable the built in filters
#play.http.filters = play.api.http.NoHttpFilters


# Job queue sized to HikariCP connection pool
post.repository {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = ${fixedConnectionPool}
  }
}
